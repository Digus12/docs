#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 0.7in
\topmargin 0.7in
\rightmargin 0.7in
\bottommargin 0.7in
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\align center

\family sans
\series bold
\size huge
Detecting and Preventing Memory Leaks
\end_layout

\begin_layout Standard
\align center

\family sans
\size larger
CS123
\end_layout

\begin_layout Standard
\align center

\size large
\begin_inset VSpace -0.1in
\end_inset


\end_layout

\begin_layout Standard
Preventing and detecting memory leaks is a crucial part of coding in C++.
 This doc describes the Valgrind Memory Analyzer, a built-in tool in QtCreator
 that automatically detects memory leaks, as well as some design patterns
 to keep in mind in order to prevent memory leaks from ever happening.
\end_layout

\begin_layout Section
Valgrind Memory Analyzer
\end_layout

\begin_layout Standard
Valgrind is a great tool for automatically detecting memory leaks, and it
 is built in to QtCreator.
 To use it, select Analyze > Valgrind Memory Analyzer.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename ValgrindMemoryAnalyzer.png
	scale 40

\end_inset


\end_layout

\begin_layout Standard
This will run your program, keeping track of the memory that is allocated
 and freed.
 After the program has finished running, you will see a message indicating
 any leaks that occurred.
 In the example below, we never deleted the ConstantBrush, so 32 bytes of
 memory were leaked.
 The message points us to the exact line where this memroy was allocated.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename MemoryLeak.png
	scale 40

\end_inset


\end_layout

\begin_layout Standard
If no memory was leaked during the execution of your program, you will not
 see any messages displayed in that section, as shown below.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename NoMemoryLeaks.png
	scale 40

\end_inset


\end_layout

\begin_layout Standard
Note that if no messages are displayed, it does not necessarily mean that
 your program is leak-free.
 It only means that no leaks occurred during that run of the program.
 For example, the code below only deletes the object if myBoolean is true.
 If myBoolean happened to be true when running Valgrind Memory Analyzer,
 no leak messages would show up, but your program can still leak memory
 if myBoolean is false.
\end_layout

\begin_layout LyX-Code
MyObject *object = new MyObject();
\end_layout

\begin_layout LyX-Code
if (myBoolean) {
\end_layout

\begin_deeper
\begin_layout LyX-Code
delete object;
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
Valgrind can be a very useful tool for detecting memory leaks, but it will
 not find them if you don't explicitly cause a certain branch of code to
 be executed while using it.
 As a result, you want to make sure you design your program such that memory
 leaks can be prevented in the first place.
\end_layout

\begin_layout Section
Preventing Memory Leaks
\end_layout

\begin_layout Standard
The rule of thumb for creating objects in C++ is that every new should correspon
d to exactly one delete.
 Certain design patterns make it easier to keep track of this correspondence
 than others.
 For example, take a look at the following code, which involves creating
 an array of integers.
\end_layout

\begin_layout LyX-Code
int* makeArray(int size, int value) {
\end_layout

\begin_deeper
\begin_layout LyX-Code
int *array = new int[size];
\end_layout

\begin_layout LyX-Code
for (int i = 0; i < size; i++) {
\end_layout

\begin_deeper
\begin_layout LyX-Code
array[i] = value;
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
return array;
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
int main(int argc, char** argv) {
\end_layout

\begin_deeper
\begin_layout LyX-Code
int *array = makeArray(5, 5);
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
// Do something with the array...
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
return 0;
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
This program leaks memory because we “new”ed an array in the makeArray function,
 but never deleted it after we were finished using it.
 However, it is not obvious just by looking at the main function that the
 array needs to be deleted, because the “new” operation is hidden inside
 makeArray.
 This design pattern is not ideal because it requires callers of makeArray
 to adhere to a specific protocol in order to use the function properly
 (i.e.
 delete the returned array when you're done with it).
\end_layout

\begin_layout Standard
Now, take a look at the alternative code below.
\end_layout

\begin_layout LyX-Code
void fillInArray(int *array, int size, int value) {
\end_layout

\begin_deeper
\begin_layout LyX-Code
for (int i = 0; i < size, i++) {
\end_layout

\begin_deeper
\begin_layout LyX-Code
array[i] = value;
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
int main(int argc, char** argv) {
\end_layout

\begin_deeper
\begin_layout LyX-Code
int *array = new int[5];
\end_layout

\begin_layout LyX-Code
fillInArray(array, 5, 5);
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
// Do something with the array...
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
delete[] array;
\end_layout

\begin_layout LyX-Code
return 0;
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
In this example, the fillInArray does not handle the creation of the array,
 just filling it in with 5's.
 With this design, it is obvious just by looking at the main function that
 the array needs to be deleted in the main function.
 By making sure the “new” and the “delete” are in logically corresponding
 places, we have avoided the need to know the details of what fillInArray
 is doing.
 Each function is responsible for its own memory.
\end_layout

\begin_layout Standard
(Another advantage to this design is it makes our helper function have a
 more explicit and stand-alone purpose.
 Rather than being a “create AND fill in array” method, it is simply a “fill
 in array” method.)
\end_layout

\begin_layout Standard
Hopefully keeping this design pattern in mind will help you prevent memory
 leaks in the future!
\end_layout

\end_body
\end_document
